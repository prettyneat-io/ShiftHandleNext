//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.2.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IPunchClockApiClient {

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param staffId (optional) 
     * @param deviceId (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @return OK
     */
    getPunchLogsAttendance(startDate?: Date | undefined, endDate?: Date | undefined, staffId?: string | undefined, deviceId?: string | undefined, page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createPunchLogAttendance(body?: PunchLog | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param staffId (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @return OK
     */
    getAttendanceRecordsAttendance(startDate?: Date | undefined, endDate?: Date | undefined, staffId?: string | undefined, page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param staffId (optional) 
     * @param status (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getCorrectionsAttendance(staffId?: string | undefined, status?: string | undefined, page?: number | undefined, limit?: number | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createCorrectionAttendance(body?: AttendanceCorrection | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getCorrectionByIdAttendance(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    approveCorrectionAttendance(id: string, body?: ApprovalRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    rejectCorrectionAttendance(id: string, body?: ApprovalRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkApproveCorrectionsAttendance(body?: BulkCorrectionRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    registerAuth(body?: RegisterRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    loginAuth(body?: LoginRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    refreshTokenAuth(body?: RefreshTokenRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    logoutAuth(signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getCurrentUserAuth(signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllDevicesDevices(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createDeviceDevices(body?: Device | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getDeviceByIdDevices(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateDeviceDevices(id: string, body?: Device | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param type (optional) 
     * @return OK
     */
    syncDeviceDevices(id: string, type?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    connectToDeviceDevices(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    disconnectFromDeviceDevices(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getDeviceUsersDevices(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getDeviceAttendanceDevices(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getDeviceDetailedInfoDevices(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    testDeviceConnectionDevices(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    enrollStaffOnDeviceDevices(deviceId: string, staffId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param fingerId (optional) 
     * @return OK
     */
    enrollStaffFingerprintDevices(deviceId: string, staffId: string, fingerId?: number | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param isActive (optional) 
     * @return OK
     */
    getLeaveTypesLeave(isActive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createLeaveTypeLeave(body?: LeaveType | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getLeaveTypeByIdLeave(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateLeaveTypeLeave(id: string, body?: LeaveType | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    deleteLeaveTypeLeave(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param staffId (optional) 
     * @param leaveTypeId (optional) 
     * @param status (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getLeaveRequestsLeave(staffId?: string | undefined, leaveTypeId?: string | undefined, status?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined, page?: number | undefined, limit?: number | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    submitLeaveRequestLeave(body?: SubmitLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getLeaveRequestByIdLeave(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    approveLeaveRequestLeave(id: string, body?: ReviewLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    rejectLeaveRequestLeave(id: string, body?: ReviewLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    cancelLeaveRequestLeave(id: string, body?: CancelLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param year (optional) 
     * @return OK
     */
    getLeaveBalanceLeave(staffId: string, year?: number | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateLeaveBalanceLeave(body?: LeaveBalanceDto | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param year (optional) 
     * @param locationId (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getHolidaysLeave(year?: number | undefined, locationId?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createHolidayLeave(body?: Holiday | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getHolidayByIdLeave(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateHolidayLeave(id: string, body?: Holiday | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    deleteHolidayLeave(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllDepartmentsOrganization(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createDepartmentOrganization(body?: Department | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllLocationsOrganization(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createLocationOrganization(body?: Location | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param isActive (optional) 
     * @param isDefault (optional) 
     * @return OK
     */
    getAllPoliciesOvertimePolicy(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, isActive?: boolean | undefined, isDefault?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createOvertimePolicy(body?: OvertimePolicy | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getByIdOvertimePolicy(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateOvertimePolicy(id: string, body?: OvertimePolicy | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    deleteOvertimePolicy(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getDefaultPolicyOvertimePolicy(signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    setAsDefaultOvertimePolicy(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param date (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @param format (optional) 
     * @return OK
     */
    getDailyReportReports(date?: Date | undefined, locationId?: string | undefined, departmentId?: string | undefined, format?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param year (optional) 
     * @param month (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @param format (optional) 
     * @return OK
     */
    getMonthlyReportReports(year?: number | undefined, month?: number | undefined, locationId?: string | undefined, departmentId?: string | undefined, format?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @param format (optional) 
     * @return OK
     */
    getPayrollReportReports(startDate?: Date | undefined, endDate?: Date | undefined, locationId?: string | undefined, departmentId?: string | undefined, format?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @return OK
     */
    getSummaryStatisticsReports(startDate?: Date | undefined, endDate?: Date | undefined, locationId?: string | undefined, departmentId?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param locationId (optional) 
     * @return OK
     */
    getDepartmentComparisonReports(startDate?: Date | undefined, endDate?: Date | undefined, locationId?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllShiftsShift(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createShiftShift(body?: Shift | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getShiftByIdShift(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateShiftShift(id: string, body?: Shift | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    deleteShiftShift(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    assignStaffToShiftShift(body?: BulkShiftAssignmentRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    unassignStaffFromShiftShift(staffId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllStaffStaff(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createStaffStaff(body?: Staff | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getStaffByIdStaff(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateStaffStaff(id: string, body?: Staff | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    deleteStaffStaff(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param includeInactive (optional) 
     * @return OK
     */
    exportStaffToCsvStaff(includeInactive?: boolean | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param updateExisting (optional) 
     * @param file (optional) 
     * @return OK
     */
    importStaffFromCsvStaff(updateExisting?: boolean | undefined, file?: FileParameter | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param file (optional) 
     * @return OK
     */
    validateStaffImportStaff(file?: FileParameter | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    assignUserToStaffStaff(staffId: string, body?: AssignUserRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    healthCheckSystem(signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getSettingsSystemSettings(signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSettingsSystemSettings(body?: any | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getSettingSystemSettings(key: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSettingSystemSettings(key: string, body?: SettingUpdateRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    resetToDefaultsSystemSettings(signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getDetailedHealthSystemSettings(signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getAllUsers(page?: number | undefined, limit?: number | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createUsers(body?: CreateUserRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    getByIdUsers(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUsers(id: string, body?: UpdateUserRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    deleteUsers(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    assignRoleUsers(id: string, roleId: string, body?: AssignRoleRequest | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    removeRoleUsers(id: string, roleId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    changePasswordUsers(id: string, body?: ChangePasswordRequest | undefined, signal?: AbortSignal): Promise<void>;
}

export class PunchClockApiClient implements IPunchClockApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param staffId (optional) 
     * @param deviceId (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @return OK
     */
    getPunchLogsAttendance(startDate?: Date | undefined, endDate?: Date | undefined, staffId?: string | undefined, deviceId?: string | undefined, page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/logs?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (staffId === null)
            throw new globalThis.Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        if (deviceId === null)
            throw new globalThis.Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (include === null)
            throw new globalThis.Error("The parameter 'include' cannot be null.");
        else if (include !== undefined)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPunchLogsAttendance(_response);
        });
    }

    protected processGetPunchLogsAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createPunchLogAttendance(body?: PunchLog | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/logs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePunchLogAttendance(_response);
        });
    }

    protected processCreatePunchLogAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param staffId (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @return OK
     */
    getAttendanceRecordsAttendance(startDate?: Date | undefined, endDate?: Date | undefined, staffId?: string | undefined, page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/records?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (staffId === null)
            throw new globalThis.Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (include === null)
            throw new globalThis.Error("The parameter 'include' cannot be null.");
        else if (include !== undefined)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttendanceRecordsAttendance(_response);
        });
    }

    protected processGetAttendanceRecordsAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param staffId (optional) 
     * @param status (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getCorrectionsAttendance(staffId?: string | undefined, status?: string | undefined, page?: number | undefined, limit?: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/corrections?";
        if (staffId === null)
            throw new globalThis.Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCorrectionsAttendance(_response);
        });
    }

    protected processGetCorrectionsAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCorrectionAttendance(body?: AttendanceCorrection | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/corrections";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCorrectionAttendance(_response);
        });
    }

    protected processCreateCorrectionAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getCorrectionByIdAttendance(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/corrections/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCorrectionByIdAttendance(_response);
        });
    }

    protected processGetCorrectionByIdAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    approveCorrectionAttendance(id: string, body?: ApprovalRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/corrections/{id}/approve";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveCorrectionAttendance(_response);
        });
    }

    protected processApproveCorrectionAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rejectCorrectionAttendance(id: string, body?: ApprovalRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/corrections/{id}/reject";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRejectCorrectionAttendance(_response);
        });
    }

    protected processRejectCorrectionAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkApproveCorrectionsAttendance(body?: BulkCorrectionRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/attendance/corrections/bulk-approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkApproveCorrectionsAttendance(_response);
        });
    }

    protected processBulkApproveCorrectionsAttendance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    registerAuth(body?: RegisterRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterAuth(_response);
        });
    }

    protected processRegisterAuth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    loginAuth(body?: LoginRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginAuth(_response);
        });
    }

    protected processLoginAuth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    refreshTokenAuth(body?: RefreshTokenRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshTokenAuth(_response);
        });
    }

    protected processRefreshTokenAuth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    logoutAuth(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogoutAuth(_response);
        });
    }

    protected processLogoutAuth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserAuth(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUserAuth(_response);
        });
    }

    protected processGetCurrentUserAuth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllDevicesDevices(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (include === null)
            throw new globalThis.Error("The parameter 'include' cannot be null.");
        else if (include !== undefined)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllDevicesDevices(_response);
        });
    }

    protected processGetAllDevicesDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createDeviceDevices(body?: Device | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDeviceDevices(_response);
        });
    }

    protected processCreateDeviceDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getDeviceByIdDevices(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceByIdDevices(_response);
        });
    }

    protected processGetDeviceByIdDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateDeviceDevices(id: string, body?: Device | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeviceDevices(_response);
        });
    }

    protected processUpdateDeviceDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @return OK
     */
    syncDeviceDevices(id: string, type?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}/sync?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncDeviceDevices(_response);
        });
    }

    protected processSyncDeviceDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    connectToDeviceDevices(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}/connect";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConnectToDeviceDevices(_response);
        });
    }

    protected processConnectToDeviceDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    disconnectFromDeviceDevices(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}/disconnect";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisconnectFromDeviceDevices(_response);
        });
    }

    protected processDisconnectFromDeviceDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getDeviceUsersDevices(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}/users";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceUsersDevices(_response);
        });
    }

    protected processGetDeviceUsersDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getDeviceAttendanceDevices(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}/attendance";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceAttendanceDevices(_response);
        });
    }

    protected processGetDeviceAttendanceDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getDeviceDetailedInfoDevices(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}/info";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceDetailedInfoDevices(_response);
        });
    }

    protected processGetDeviceDetailedInfoDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    testDeviceConnectionDevices(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{id}/test-connection";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestDeviceConnectionDevices(_response);
        });
    }

    protected processTestDeviceConnectionDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    enrollStaffOnDeviceDevices(deviceId: string, staffId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{deviceId}/staff/{staffId}/enroll";
        if (deviceId === undefined || deviceId === null)
            throw new globalThis.Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (staffId === undefined || staffId === null)
            throw new globalThis.Error("The parameter 'staffId' must be defined.");
        url_ = url_.replace("{staffId}", encodeURIComponent("" + staffId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnrollStaffOnDeviceDevices(_response);
        });
    }

    protected processEnrollStaffOnDeviceDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param fingerId (optional) 
     * @return OK
     */
    enrollStaffFingerprintDevices(deviceId: string, staffId: string, fingerId?: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/devices/{deviceId}/staff/{staffId}/enroll-fingerprint?";
        if (deviceId === undefined || deviceId === null)
            throw new globalThis.Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (staffId === undefined || staffId === null)
            throw new globalThis.Error("The parameter 'staffId' must be defined.");
        url_ = url_.replace("{staffId}", encodeURIComponent("" + staffId));
        if (fingerId === null)
            throw new globalThis.Error("The parameter 'fingerId' cannot be null.");
        else if (fingerId !== undefined)
            url_ += "fingerId=" + encodeURIComponent("" + fingerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnrollStaffFingerprintDevices(_response);
        });
    }

    protected processEnrollStaffFingerprintDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return OK
     */
    getLeaveTypesLeave(isActive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/types?";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeaveTypesLeave(_response);
        });
    }

    protected processGetLeaveTypesLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createLeaveTypeLeave(body?: LeaveType | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeaveTypeLeave(_response);
        });
    }

    protected processCreateLeaveTypeLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getLeaveTypeByIdLeave(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/types/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeaveTypeByIdLeave(_response);
        });
    }

    protected processGetLeaveTypeByIdLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateLeaveTypeLeave(id: string, body?: LeaveType | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/types/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeaveTypeLeave(_response);
        });
    }

    protected processUpdateLeaveTypeLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteLeaveTypeLeave(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/types/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLeaveTypeLeave(_response);
        });
    }

    protected processDeleteLeaveTypeLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param staffId (optional) 
     * @param leaveTypeId (optional) 
     * @param status (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getLeaveRequestsLeave(staffId?: string | undefined, leaveTypeId?: string | undefined, status?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined, page?: number | undefined, limit?: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/requests?";
        if (staffId === null)
            throw new globalThis.Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        if (leaveTypeId === null)
            throw new globalThis.Error("The parameter 'leaveTypeId' cannot be null.");
        else if (leaveTypeId !== undefined)
            url_ += "leaveTypeId=" + encodeURIComponent("" + leaveTypeId) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeaveRequestsLeave(_response);
        });
    }

    protected processGetLeaveRequestsLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submitLeaveRequestLeave(body?: SubmitLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/requests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitLeaveRequestLeave(_response);
        });
    }

    protected processSubmitLeaveRequestLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getLeaveRequestByIdLeave(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/requests/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeaveRequestByIdLeave(_response);
        });
    }

    protected processGetLeaveRequestByIdLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    approveLeaveRequestLeave(id: string, body?: ReviewLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/requests/{id}/approve";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveLeaveRequestLeave(_response);
        });
    }

    protected processApproveLeaveRequestLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rejectLeaveRequestLeave(id: string, body?: ReviewLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/requests/{id}/reject";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRejectLeaveRequestLeave(_response);
        });
    }

    protected processRejectLeaveRequestLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    cancelLeaveRequestLeave(id: string, body?: CancelLeaveRequestDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/requests/{id}/cancel";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelLeaveRequestLeave(_response);
        });
    }

    protected processCancelLeaveRequestLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param year (optional) 
     * @return OK
     */
    getLeaveBalanceLeave(staffId: string, year?: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/balance/{staffId}?";
        if (staffId === undefined || staffId === null)
            throw new globalThis.Error("The parameter 'staffId' must be defined.");
        url_ = url_.replace("{staffId}", encodeURIComponent("" + staffId));
        if (year === null)
            throw new globalThis.Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeaveBalanceLeave(_response);
        });
    }

    protected processGetLeaveBalanceLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateLeaveBalanceLeave(body?: LeaveBalanceDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/balance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdateLeaveBalanceLeave(_response);
        });
    }

    protected processCreateOrUpdateLeaveBalanceLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param year (optional) 
     * @param locationId (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getHolidaysLeave(year?: number | undefined, locationId?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/holidays?";
        if (year === null)
            throw new globalThis.Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (locationId === null)
            throw new globalThis.Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHolidaysLeave(_response);
        });
    }

    protected processGetHolidaysLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createHolidayLeave(body?: Holiday | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/holidays";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateHolidayLeave(_response);
        });
    }

    protected processCreateHolidayLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getHolidayByIdLeave(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/holidays/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHolidayByIdLeave(_response);
        });
    }

    protected processGetHolidayByIdLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateHolidayLeave(id: string, body?: Holiday | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/holidays/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateHolidayLeave(_response);
        });
    }

    protected processUpdateHolidayLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteHolidayLeave(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/leave/holidays/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteHolidayLeave(_response);
        });
    }

    protected processDeleteHolidayLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllDepartmentsOrganization(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/departments?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (include === null)
            throw new globalThis.Error("The parameter 'include' cannot be null.");
        else if (include !== undefined)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllDepartmentsOrganization(_response);
        });
    }

    protected processGetAllDepartmentsOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createDepartmentOrganization(body?: Department | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/departments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDepartmentOrganization(_response);
        });
    }

    protected processCreateDepartmentOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllLocationsOrganization(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/locations?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (include === null)
            throw new globalThis.Error("The parameter 'include' cannot be null.");
        else if (include !== undefined)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllLocationsOrganization(_response);
        });
    }

    protected processGetAllLocationsOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createLocationOrganization(body?: Location | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/locations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLocationOrganization(_response);
        });
    }

    protected processCreateLocationOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param isActive (optional) 
     * @param isDefault (optional) 
     * @return OK
     */
    getAllPoliciesOvertimePolicy(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, isActive?: boolean | undefined, isDefault?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/overtime-policies?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (isDefault === null)
            throw new globalThis.Error("The parameter 'isDefault' cannot be null.");
        else if (isDefault !== undefined)
            url_ += "isDefault=" + encodeURIComponent("" + isDefault) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPoliciesOvertimePolicy(_response);
        });
    }

    protected processGetAllPoliciesOvertimePolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOvertimePolicy(body?: OvertimePolicy | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/overtime-policies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOvertimePolicy(_response);
        });
    }

    protected processCreateOvertimePolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getByIdOvertimePolicy(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/overtime-policies/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByIdOvertimePolicy(_response);
        });
    }

    protected processGetByIdOvertimePolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateOvertimePolicy(id: string, body?: OvertimePolicy | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/overtime-policies/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateOvertimePolicy(_response);
        });
    }

    protected processUpdateOvertimePolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteOvertimePolicy(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/overtime-policies/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOvertimePolicy(_response);
        });
    }

    protected processDeleteOvertimePolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getDefaultPolicyOvertimePolicy(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/overtime-policies/default";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefaultPolicyOvertimePolicy(_response);
        });
    }

    protected processGetDefaultPolicyOvertimePolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    setAsDefaultOvertimePolicy(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/overtime-policies/{id}/set-default";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetAsDefaultOvertimePolicy(_response);
        });
    }

    protected processSetAsDefaultOvertimePolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param date (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @param format (optional) 
     * @return OK
     */
    getDailyReportReports(date?: Date | undefined, locationId?: string | undefined, departmentId?: string | undefined, format?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/reports/daily?";
        if (date === null)
            throw new globalThis.Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (locationId === null)
            throw new globalThis.Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDailyReportReports(_response);
        });
    }

    protected processGetDailyReportReports(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param year (optional) 
     * @param month (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @param format (optional) 
     * @return OK
     */
    getMonthlyReportReports(year?: number | undefined, month?: number | undefined, locationId?: string | undefined, departmentId?: string | undefined, format?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/reports/monthly?";
        if (year === null)
            throw new globalThis.Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new globalThis.Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (locationId === null)
            throw new globalThis.Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMonthlyReportReports(_response);
        });
    }

    protected processGetMonthlyReportReports(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @param format (optional) 
     * @return OK
     */
    getPayrollReportReports(startDate?: Date | undefined, endDate?: Date | undefined, locationId?: string | undefined, departmentId?: string | undefined, format?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/reports/payroll?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (locationId === null)
            throw new globalThis.Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPayrollReportReports(_response);
        });
    }

    protected processGetPayrollReportReports(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param locationId (optional) 
     * @param departmentId (optional) 
     * @return OK
     */
    getSummaryStatisticsReports(startDate?: Date | undefined, endDate?: Date | undefined, locationId?: string | undefined, departmentId?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/reports/summary?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (locationId === null)
            throw new globalThis.Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummaryStatisticsReports(_response);
        });
    }

    protected processGetSummaryStatisticsReports(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param locationId (optional) 
     * @return OK
     */
    getDepartmentComparisonReports(startDate?: Date | undefined, endDate?: Date | undefined, locationId?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/reports/departments?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (locationId === null)
            throw new globalThis.Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentComparisonReports(_response);
        });
    }

    protected processGetDepartmentComparisonReports(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllShiftsShift(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/shifts?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (include === null)
            throw new globalThis.Error("The parameter 'include' cannot be null.");
        else if (include !== undefined)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllShiftsShift(_response);
        });
    }

    protected processGetAllShiftsShift(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createShiftShift(body?: Shift | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/shifts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateShiftShift(_response);
        });
    }

    protected processCreateShiftShift(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getShiftByIdShift(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/shifts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShiftByIdShift(_response);
        });
    }

    protected processGetShiftByIdShift(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateShiftShift(id: string, body?: Shift | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/shifts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateShiftShift(_response);
        });
    }

    protected processUpdateShiftShift(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteShiftShift(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/shifts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteShiftShift(_response);
        });
    }

    protected processDeleteShiftShift(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assignStaffToShiftShift(body?: BulkShiftAssignmentRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/shifts/assign-staff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignStaffToShiftShift(_response);
        });
    }

    protected processAssignStaffToShiftShift(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    unassignStaffFromShiftShift(staffId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/shifts/unassign-staff/{staffId}";
        if (staffId === undefined || staffId === null)
            throw new globalThis.Error("The parameter 'staffId' must be defined.");
        url_ = url_.replace("{staffId}", encodeURIComponent("" + staffId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnassignStaffFromShiftShift(_response);
        });
    }

    protected processUnassignStaffFromShiftShift(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param order (optional) 
     * @param include (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    getAllStaffStaff(page?: number | undefined, limit?: number | undefined, sort?: string | undefined, order?: string | undefined, include?: string | undefined, isActive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new globalThis.Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        if (include === null)
            throw new globalThis.Error("The parameter 'include' cannot be null.");
        else if (include !== undefined)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllStaffStaff(_response);
        });
    }

    protected processGetAllStaffStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createStaffStaff(body?: Staff | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateStaffStaff(_response);
        });
    }

    protected processCreateStaffStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getStaffByIdStaff(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStaffByIdStaff(_response);
        });
    }

    protected processGetStaffByIdStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateStaffStaff(id: string, body?: Staff | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStaffStaff(_response);
        });
    }

    protected processUpdateStaffStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteStaffStaff(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteStaffStaff(_response);
        });
    }

    protected processDeleteStaffStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param includeInactive (optional) 
     * @return OK
     */
    exportStaffToCsvStaff(includeInactive?: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff/export/csv?";
        if (includeInactive === null)
            throw new globalThis.Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportStaffToCsvStaff(_response);
        });
    }

    protected processExportStaffToCsvStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param updateExisting (optional) 
     * @param file (optional) 
     * @return OK
     */
    importStaffFromCsvStaff(updateExisting?: boolean | undefined, file?: FileParameter | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff/import/csv?";
        if (updateExisting === null)
            throw new globalThis.Error("The parameter 'updateExisting' cannot be null.");
        else if (updateExisting !== undefined)
            url_ += "updateExisting=" + encodeURIComponent("" + updateExisting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportStaffFromCsvStaff(_response);
        });
    }

    protected processImportStaffFromCsvStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    validateStaffImportStaff(file?: FileParameter | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff/import/csv/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateStaffImportStaff(_response);
        });
    }

    protected processValidateStaffImportStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assignUserToStaffStaff(staffId: string, body?: AssignUserRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/staff/{staffId}/assign-user";
        if (staffId === undefined || staffId === null)
            throw new globalThis.Error("The parameter 'staffId' must be defined.");
        url_ = url_.replace("{staffId}", encodeURIComponent("" + staffId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignUserToStaffStaff(_response);
        });
    }

    protected processAssignUserToStaffStaff(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    healthCheckSystem(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealthCheckSystem(_response);
        });
    }

    protected processHealthCheckSystem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getSettingsSystemSettings(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/system/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettingsSystemSettings(_response);
        });
    }

    protected processGetSettingsSystemSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSettingsSystemSettings(body?: any | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/system/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSettingsSystemSettings(_response);
        });
    }

    protected processUpdateSettingsSystemSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getSettingSystemSettings(key: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/system/settings/{key}";
        if (key === undefined || key === null)
            throw new globalThis.Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettingSystemSettings(_response);
        });
    }

    protected processGetSettingSystemSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSettingSystemSettings(key: string, body?: SettingUpdateRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/system/settings/{key}";
        if (key === undefined || key === null)
            throw new globalThis.Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSettingSystemSettings(_response);
        });
    }

    protected processUpdateSettingSystemSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resetToDefaultsSystemSettings(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/system/settings/reset";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetToDefaultsSystemSettings(_response);
        });
    }

    protected processResetToDefaultsSystemSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getDetailedHealthSystemSettings(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/system/settings/health/detailed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailedHealthSystemSettings(_response);
        });
    }

    protected processGetDetailedHealthSystemSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getAllUsers(page?: number | undefined, limit?: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createUsers(body?: CreateUserRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUsers(_response);
        });
    }

    protected processCreateUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getByIdUsers(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByIdUsers(_response);
        });
    }

    protected processGetByIdUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUsers(id: string, body?: UpdateUserRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUsers(_response);
        });
    }

    protected processUpdateUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteUsers(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUsers(_response);
        });
    }

    protected processDeleteUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assignRoleUsers(id: string, roleId: string, body?: AssignRoleRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}/roles/{roleId}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (roleId === undefined || roleId === null)
            throw new globalThis.Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignRoleUsers(_response);
        });
    }

    protected processAssignRoleUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    removeRoleUsers(id: string, roleId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}/roles/{roleId}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (roleId === undefined || roleId === null)
            throw new globalThis.Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveRoleUsers(_response);
        });
    }

    protected processRemoveRoleUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changePasswordUsers(id: string, body?: ChangePasswordRequest | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}/password";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePasswordUsers(_response);
        });
    }

    protected processChangePasswordUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ApprovalRequest {
    notes?: string | undefined;
}

export interface AssignRoleRequest {
    expiresAt?: Date | undefined;
}

export interface AssignUserRequest {
    userId?: string;
}

export interface AttendanceCorrection {
    correctionId?: string;
    recordId?: string;
    staffId?: string;
    attendanceDate?: Date;
    correctionType?: string | undefined;
    originalClockIn?: Date | undefined;
    originalClockOut?: Date | undefined;
    correctedClockIn?: Date | undefined;
    correctedClockOut?: Date | undefined;
    reason?: string | undefined;
    supportingDocuments?: string | undefined;
    status?: string | undefined;
    requestedBy?: string;
    requestedAt?: Date;
    reviewedBy?: string | undefined;
    reviewedAt?: Date | undefined;
    reviewNotes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    record?: AttendanceRecord;
    staff?: Staff;
    requestedByUser?: User;
    reviewedByUser?: User;
}

export interface AttendanceRecord {
    recordId?: string;
    staffId?: string;
    attendanceDate?: Date;
    clockIn?: Date | undefined;
    clockOut?: Date | undefined;
    totalHours?: string | undefined;
    regularHours?: string | undefined;
    overtimeHours?: string | undefined;
    breakDuration?: string | undefined;
    lateMinutes?: number | undefined;
    earlyLeaveMinutes?: number | undefined;
    attendanceStatus?: string | undefined;
    notes?: string | undefined;
    isApproved?: boolean;
    approvedAt?: Date | undefined;
    approvedBy?: string | undefined;
    hasAnomalies?: boolean;
    anomalyFlags?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    modifiedBy?: string | undefined;
    staff?: Staff;
}

export interface AuditLog {
    auditId?: string;
    tableName?: string | undefined;
    recordId?: string | undefined;
    action?: string | undefined;
    oldValues?: string | undefined;
    newValues?: string | undefined;
    userId?: string | undefined;
    performedAt?: Date;
    user?: User;
}

export interface BiometricTemplate {
    templateId?: string;
    staffId?: string;
    templateType?: string | undefined;
    templateData?: string | undefined;
    templateFormat?: string | undefined;
    fingerIndex?: number | undefined;
    qualityScore?: number | undefined;
    isPrimary?: boolean;
    isActive?: boolean;
    enrolledAt?: Date;
    enrolledBy?: string | undefined;
    deviceId?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    staff?: Staff;
    device?: Device;
}

export interface BulkCorrectionRequest {
    correctionIds?: string[] | undefined;
    action?: string | undefined;
    notes?: string | undefined;
}

export interface BulkShiftAssignmentRequest {
    shiftId?: string;
    staffIds?: string[] | undefined;
}

export interface CancelLeaveRequestDto {
    reason?: string | undefined;
}

export interface ChangePasswordRequest {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
}

export interface CreateUserRequest {
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean | undefined;
    isVerified?: boolean | undefined;
}

export interface Department {
    departmentId?: string;
    departmentName?: string | undefined;
    departmentCode?: string | undefined;
    parentDepartmentId?: string | undefined;
    managerStaffId?: string | undefined;
    overtimePolicyId?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    parentDepartment?: Department;
    subDepartments?: Department[] | undefined;
    staffMembers?: Staff[] | undefined;
    overtimePolicy?: OvertimePolicy;
}

export interface Device {
    deviceId?: string;
    deviceSerial?: string | undefined;
    deviceName?: string | undefined;
    deviceModel?: string | undefined;
    manufacturer?: string | undefined;
    firmwareVersion?: string | undefined;
    ipAddress?: string | undefined;
    macAddress?: string | undefined;
    port?: number;
    connectionType?: string | undefined;
    locationId?: string | undefined;
    installationDate?: Date | undefined;
    userCapacity?: number | undefined;
    logCapacity?: number | undefined;
    fingerprintCapacity?: number | undefined;
    faceCapacity?: number | undefined;
    isActive?: boolean;
    isOnline?: boolean;
    lastSyncAt?: Date | undefined;
    lastHeartbeatAt?: Date | undefined;
    deviceConfig?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    location?: Location;
    deviceEnrollments?: DeviceEnrollment[] | undefined;
    punchLogs?: PunchLog[] | undefined;
    syncLogs?: SyncLog[] | undefined;
    biometricTemplates?: BiometricTemplate[] | undefined;
}

export interface DeviceEnrollment {
    enrollmentId?: string;
    deviceId?: string;
    staffId?: string;
    deviceUserId?: number | undefined;
    enrollmentStatus?: string | undefined;
    enrolledAt?: Date | undefined;
    lastSyncAt?: Date | undefined;
    syncStatus?: string | undefined;
    syncErrorMessage?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    device?: Device;
    staff?: Staff;
}

export interface Holiday {
    holidayId?: string;
    holidayName?: string | undefined;
    holidayDate?: Date;
    locationId?: string | undefined;
    isRecurring?: boolean;
    isMandatory?: boolean;
    isPaid?: boolean;
    description?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    location?: Location;
}

export interface LeaveBalance {
    leaveBalanceId?: string;
    staffId?: string;
    leaveTypeId?: string;
    year?: number;
    totalAllocation?: number;
    carryForward?: number;
    used?: number;
    pending?: number;
    available?: number;
    lastAccrualDate?: Date | undefined;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    staff?: Staff;
    leaveType?: LeaveType;
}

export interface LeaveBalanceDto {
    staffId?: string;
    leaveTypeId?: string;
    year?: number;
    totalAllocation?: number;
    carryForward?: number;
    notes?: string | undefined;
}

export interface LeaveRequest {
    leaveRequestId?: string;
    staffId?: string;
    leaveTypeId?: string;
    startDate?: Date;
    endDate?: Date;
    totalDays?: number;
    totalHours?: string | undefined;
    reason?: string | undefined;
    supportingDocuments?: string | undefined;
    status?: string | undefined;
    requestedBy?: string;
    requestedAt?: Date;
    reviewedBy?: string | undefined;
    reviewedAt?: Date | undefined;
    reviewNotes?: string | undefined;
    cancelledAt?: Date | undefined;
    cancelledBy?: string | undefined;
    cancellationReason?: string | undefined;
    affectsAttendance?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    staff?: Staff;
    leaveType?: LeaveType;
    requestedByUser?: User;
    reviewedByUser?: User;
    cancelledByUser?: User;
}

export interface LeaveType {
    leaveTypeId?: string;
    typeName?: string | undefined;
    typeCode?: string | undefined;
    description?: string | undefined;
    requiresApproval?: boolean;
    requiresDocumentation?: boolean;
    maxDaysPerYear?: number | undefined;
    minDaysNotice?: number | undefined;
    isPaid?: boolean;
    allowsHalfDay?: boolean;
    allowsHourly?: boolean;
    color?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    leaveRequests?: LeaveRequest[] | undefined;
    leaveBalances?: LeaveBalance[] | undefined;
}

export interface Location {
    locationId?: string;
    locationName?: string | undefined;
    locationCode?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    city?: string | undefined;
    stateProvince?: string | undefined;
    postalCode?: string | undefined;
    country?: string | undefined;
    timezone?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    devices?: Device[] | undefined;
    staffMembers?: Staff[] | undefined;
    holidays?: Holiday[] | undefined;
}

export interface LoginRequest {
    username?: string | undefined;
    password?: string | undefined;
}

export interface OvertimePolicy {
    policyId?: string;
    policyName?: string | undefined;
    policyCode?: string | undefined;
    description?: string | undefined;
    dailyThreshold?: string;
    dailyMultiplier?: number;
    applyWeeklyRule?: boolean;
    weeklyThreshold?: string;
    weeklyMultiplier?: number;
    applyWeekendRule?: boolean;
    weekendMultiplier?: number;
    applyHolidayRule?: boolean;
    holidayMultiplier?: number;
    maxDailyOvertime?: string | undefined;
    minimumOvertimeMinutes?: number;
    autoApprovalThreshold?: string | undefined;
    effectiveFrom?: Date;
    effectiveTo?: Date | undefined;
    isActive?: boolean;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    shifts?: Shift[] | undefined;
    departments?: Department[] | undefined;
}

export interface Permission {
    permissionId?: string;
    permissionName?: string | undefined;
    permissionDescription?: string | undefined;
    resource?: string | undefined;
    action?: string | undefined;
    createdAt?: Date;
    rolePermissions?: RolePermission[] | undefined;
}

export interface PunchLog {
    logId?: string;
    staffId?: string | undefined;
    deviceId?: string | undefined;
    punchTime?: Date;
    punchType?: string | undefined;
    verificationMode?: string | undefined;
    deviceUserId?: number | undefined;
    deviceLogId?: number | undefined;
    workCode?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    isProcessed?: boolean;
    processedAt?: Date | undefined;
    isManualEntry?: boolean;
    manualEntryReason?: string | undefined;
    isValid?: boolean;
    validationErrors?: string | undefined;
    createdAt?: Date;
    importedAt?: Date;
    modifiedAt?: Date | undefined;
    modifiedBy?: string | undefined;
    staff?: Staff;
    device?: Device;
}

export interface RefreshTokenRequest {
    refreshToken?: string | undefined;
}

export interface RegisterRequest {
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
}

export interface ReviewLeaveRequestDto {
    notes?: string | undefined;
}

export interface Role {
    roleId?: string;
    roleName?: string | undefined;
    roleDescription?: string | undefined;
    isSystemRole?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    userRoles?: UserRole[] | undefined;
    rolePermissions?: RolePermission[] | undefined;
}

export interface RolePermission {
    roleId?: string;
    permissionId?: string;
    grantedAt?: Date;
    grantedBy?: string | undefined;
    role?: Role;
    permission?: Permission;
}

export interface SettingUpdateRequest {
    value?: string | undefined;
    description?: string | undefined;
}

export interface Shift {
    shiftId?: string;
    shiftName?: string | undefined;
    shiftCode?: string | undefined;
    startTime?: string;
    endTime?: string;
    requiredHours?: string;
    gracePeriodMinutes?: number;
    lateThresholdMinutes?: number;
    earlyLeaveThresholdMinutes?: number;
    hasBreak?: boolean;
    breakDuration?: string | undefined;
    breakStartTime?: string | undefined;
    autoDeductBreak?: boolean;
    overtimePolicyId?: string | undefined;
    isActive?: boolean;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    overtimePolicy?: OvertimePolicy;
    staffMembers?: Staff[] | undefined;
}

export interface Staff {
    staffId?: string;
    employeeId?: string | undefined;
    badgeNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    mobile?: string | undefined;
    departmentId?: string | undefined;
    locationId?: string | undefined;
    shiftId?: string | undefined;
    positionTitle?: string | undefined;
    employmentType?: string | undefined;
    hireDate?: Date;
    terminationDate?: Date | undefined;
    isActive?: boolean;
    enrollmentStatus?: string | undefined;
    userId?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    department?: Department;
    location?: Location;
    shift?: Shift;
    user?: User;
    biometricTemplates?: BiometricTemplate[] | undefined;
    deviceEnrollments?: DeviceEnrollment[] | undefined;
    punchLogs?: PunchLog[] | undefined;
    attendanceRecords?: AttendanceRecord[] | undefined;
    leaveRequests?: LeaveRequest[] | undefined;
    leaveBalances?: LeaveBalance[] | undefined;
}

export interface SubmitLeaveRequestDto {
    staffId?: string;
    leaveTypeId?: string;
    startDate?: Date;
    endDate?: Date;
    reason?: string | undefined;
    isHalfDay?: boolean;
    totalHours?: string | undefined;
    supportingDocuments?: string | undefined;
}

export interface SyncLog {
    syncId?: string;
    deviceId?: string | undefined;
    syncType?: string | undefined;
    syncStatus?: string | undefined;
    status?: string | undefined;
    startedAt?: Date;
    completedAt?: Date | undefined;
    recordsProcessed?: number | undefined;
    recordsSynced?: number | undefined;
    recordsFailed?: number | undefined;
    errorMessage?: string | undefined;
    errorDetails?: string | undefined;
    initiatedBy?: string | undefined;
    createdAt?: Date;
    device?: Device;
}

export interface UpdateUserRequest {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean | undefined;
    isVerified?: boolean | undefined;
}

export interface User {
    userId?: string;
    username?: string | undefined;
    email?: string | undefined;
    passwordHash?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    isVerified?: boolean;
    lastLogin?: Date | undefined;
    passwordResetToken?: string | undefined;
    passwordResetExpires?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    userRoles?: UserRole[] | undefined;
    auditLogs?: AuditLog[] | undefined;
    requestedLeaveRequests?: LeaveRequest[] | undefined;
    reviewedLeaveRequests?: LeaveRequest[] | undefined;
    cancelledLeaveRequests?: LeaveRequest[] | undefined;
}

export interface UserRole {
    userId?: string;
    roleId?: string;
    assignedAt?: Date;
    assignedBy?: string | undefined;
    expiresAt?: Date | undefined;
    user?: User;
    role?: Role;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}